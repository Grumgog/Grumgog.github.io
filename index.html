<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<title>Справка Emula80</title>
		<link rel="stylesheet" href="index.css"/>
	</head>
	<body>
		<H1>Что такое Emula80?</H1>
		<div>
			Emula80 - интерактивный интерпретатор ассемблера c intel-подобным синтаксисом
			предназначенный для обучения и ознакомления с главными принципами программирования
			на языках ассемблера. Подмножество языка ассемблера представленного в данной
			программе является <a href="https://ru.wikipedia.org/wiki/Полнота_по_Тьюрингу">полным поТьюрингу</a>.
		</div>
		<h2>Что умеет Emula80?</h2>
		<div>
			Emula80 - представляет собой приложение предоставляющее
			интерактивную оболочку для программирования на
			подмножестве команд ассемблера (c кодовым именем EmuLang). Главной
			особенностью программы является способность отображать
			состояние регистров виртуального процессора и памяти
			виртуальной машины на которой выполняется программа.
			Так же местная реализация ассемблера может допускать
			нескольких вариантов написания инструкций (что несколько
			ослабляет требования к правильности написания синтаксиса)
			и позволяет сконцентрироваться на обучении.
		</div>
		<h2>Ограничения Emula80</h2>
		<div>
			Несмотря на цель создать максимально правдоподобный аналог
			ассемблера, в Emula80 содержится несколько ограничений
			наложенных с целью упростить внутреннею реализацию, а также
			внешний интерфейс программы. Так в Emula80 поддерживается
			только один тип данных (int32). Все регистры моделируемого
			процессора и ячейки памяти виртуальной машины так же
			имеют этот тип данных. Так же подмножество языка было
			урезано до команд арифметики, операций с регистрами,
			определения процедур, операций с памятью. Многие команды
			из множества команд процессоров семейства x86-x64
			в данном приложении не доступны, что позволяет
			использовать Emula80 только в учебных целях.
		</div>
		<a name="Main"/>
		<h2>Справочная система</h2>
		<div>
			<ol>
				<li><a href="#SyntaxBase">Основы синтаксиса</a></li>
				<li><a href="#Comands">Система команд</a></li>
				<li><a href="#Registrs">Регистры и их назначение</a></li>
				<li><a href="#DevEmula">Интерактивная оболочка</a></li>
			</ol>
		</div>
		<a name="SyntaxBase"/>
		<h2>Основы синтаксиса</h2>
		<div>
			Реализация ассемблера в данном приложении не требует особых
			требований к структуризации программ на EmuLang. Синтаксический
			анализатор реализованный является плоским и считывает информацию
			последовательно, игнорируя знаки пробелов (кроме тех случаев когда
			они разделяют лексемы), а так же запятые и символы перевода каретки.
			Практически это означает что можно написать корректную программу в
			одну строку без специальных символов-разделителей.
			Главным требованием синтаксиса является что бы каждое значимое
			выражение начиналось с оператора.
			<div>
				<h3 class="codeHeader">Пример корректной программы</h3>
				<div class="codeBody">
					1 |MOV EAX 4<br>
					2 |MOV EBX, 12<br>
					3 |MUL EAX, EBX ADD EAX 1<br>
				</div>
			</div>
			Как можно увидеть в данном примере, разбивать программу на строки
			строго не обязательно, так же необязательно отделять аргументы
			операторов запятой.
			<a name="TokenStream"/>
			<h3>Особенности Работы</h3>
			Текст программы разбивается на лексемы, затем каждой лексеме
			присваивается номер. Этот номер будет адресом данной лексемы.
			По этому адресу можно переходить с помощью регистра IAR.
			Однако надо быть острожным, так как "не операторы" тоже имеют свой
			адресс и интерпретатор выдаст ошибку при попытке выполнить "EAX" или
			другую подобную "не инструкцию".
		</div>
		<a name="Comands"/>
		<h2>Система команд</h2>
		<div>
			EmuLang реализует маленькое подмножество команд семейства
			x86-x64 в которое вошли базовые команды этого семейства
			процессоров.<br>
			Обозначения
			<ul>
				<li>[REG] - Имя регистра</li>
				<li>[data] - информация в виде числа формата int32</li>
				<li>[MEM] - номер ячейки памяти в виде числа формата int32</li>
				<li>[Label] - текстовая метка в коде программы</li>
				<ul>
			<h3 class="codeHeader">Команды и примеры</h3>
				<div class="codeBody">
					1 | LOAD [REG] [MEM] - Загружает данные из памяти в регистр<br>
					2 | STORE [REG] [MEM] - Ложит данные из регистра в ячейку памяти<br>
					3 | PUSH [REG] - заталкивает данные в стек<br>
					4 | POP [REG] - выталкивает данные из стека<br>
					5 | ADD [REG] [REG] - складывает данные<br>
					6 | ADD [REG] [DATA] - складывает данные<br>
					7 | SUB [REG] [REG] - вычитает<br>
					8 | SUB [REG] [DATA] - вычитает<br>
					9 | MUL [REG] [REG] - умножает<br>
					10| MUL [REG] [DATA] - умножает<br>
					11| DIV [REG] [REG] - делит<br>
					12| DIV [REG] [DATA] - делит<br>
					13| EXCH [REG] [REG] - обменивает содержимое регистров<br>
					14| JMP [LABEL] - безусловный прыжок<br>
					15| JGT [LABEL] - прыжок (если больше)<br>
					16| JLT [LABEL] - прыжок (если меньше)<br>
					17| JEQ [LABEL] - прыжок (если равно)<br>
					18| CMP [REG] [REG] - сравнение<br>
					19| MOV [REG] [DATA] - присваивание<br>
					20| MOV [REG] [REG] - присваивание<br>
					21| PROC [LABEL] - объявление процедуры<br>
					22| ENDPROC - конец объявления процедуры<br>
					23| CALL [LABEL] - вызов процедуры по имени<br>
					24| LABEL: - метка в коде программы<br>
				</div>
		</div>
		<a name="Registrs"/>
		<h2>Регистры и их назначение</h2>
		<div>
			<h3>Регистры общего назначения</h3>
			Могут быть использованы для любых операций над регистрами
			<ol>
				<li>EAX</li>
				<li>EBX</li>
				<li>ECX</li>
				<li>EDX</li>
				<li>EFX</li>
				<li>EGX</li>
				<li>ESX</li>
				<li>EPX - регистр общего назначения, но хранит адрес вершины стека</li>
			</ol>
			<h3>Регистры специального назначения</h3>
			Используются для хранения специальной информации, хотя они и
			доступны для изменения, не рекомендуется их изменять, если
			программист не может предвидеть результата.
			<ol>
				<li>IAR - Содержит номер инструкции программы.<a href="#TokenStream">*</a></li>
				<li>DRF - Флаг отладки = 1 если программа выполняется пошагово</li>
				<li>RET - Содержит номер инструкции<a href="#TokenStream">*</a> для возврата из процедуры</li>
				<li>STE - Адрес конца стека</li>
				<li>CRF - Флаговый регистр сравнения</li>
			</ol>
		</div>
		<a name="DevEmula"/>
		<h2>Интерактивная оболочка</h2>
		<div>
			Интерактивная оболочка предназначена для программирования и интерактивного
			отслеживания информации. Программа имеет одно главное окно поделенное на
			следующие области.<br>
			<img src="./img/interface.png" style="margin:5px; position: center;" />
			<ol>
				<li>Элемент текстового ввода, для программного кода. Именно тут будет размещаться
					код программы</li>
				<li>Здесь отображается информация о регистрах и памяти виртуальной машины</li>
				<li>Здесь выводятся сообщения от интерпретатора</li>
				<li>Панель инструментов - манипуляции с файлами, и не посредственно с исполнением программы</li>
			</ol>
				
		</div>
		<footer>
		Василий@Grumgog<br>
		Текст документации может не описывать всех функций программы. Для более полной документации
		Ищите наиболее актуальную версию на grumgog.github.io
		</footer>
	</body>
</html>